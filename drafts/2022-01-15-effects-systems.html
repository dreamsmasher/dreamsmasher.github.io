<!doctype html>
<html lang="en">
    <head>
        <link id="favicon" rel="icon" type="image/svg+xml" href="../images/favicon.svg">
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color content=" #121111"> 
        <meta property="og:type" content="website" />
        <meta property="og:title" content="a" type cosmonaut's guide to effects systems />
        
        <meta name="description" property="og:description" content="nliu.net -> " />
        
        <meta property="og:type" content="website" />
        <meta property="og:image" content="../images/nliu-logo.png" />
        
        <title>a type cosmonaut's guide to effects systems - Norman Liu's blog</title>
        
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        

        
        
          <meta name="keywords" content>
        
    </head>
    <body>
        <header>
            <div class="logo"> 
                <a href="../">λ <- neon lambdas</a>
            </div>
            <nav>
                <a href="../">Home</a>
                
                <a href="../about.html">About</a>

                <a href="../contact.html">Contact</a>

                <a href="../projects.html">Projects</a>

                <a href="../archive.html">Archive</a>

            </nav>
            <hr class="head_delim">
        </header>

          <div id="content">
        <main role="main">
                        <article>
    <section class="header">
      <h1>a type cosmonaut's guide to effects systems</h1>
      Written: <span class="date">2022-01-15</span> 
      <!--  -->
        
      
      
    </section>
    <section>
        <p>I’ve been playing around with type-level <del>fuckery</del> programming lately, and something in my head finally clicked when it came to libraries like <a href="https://hackage.haskell.org/package/freer-simple">freer-simple</a> and <a href="https://hackage.haskell.org/package/polysemy">polysemy</a>. For context, Haskell applications usually take one of a few approaches to managing complex contextual interactions, like unlifting everything to <code class="inline-type">ReaderT + IO</code>, monad transformer stacks, or algebraic effects systems. I’m partial to monad transformers for their composability, but there are a few issues that impact UX and extensibility.</p>
<p>Let’s say you had a simple CRUD app, that needs to be able to log errors, make database calls, and respond to HTTP requests.</p>
<p>You might define a typeclass like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasConnection</span> m <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  getConnection ::</span> m <span class="dt">Connection</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- or if you're fancy:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- class HasConnection env wheree</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">--   getConnection :: Lens' env Connection</span></span></code></pre></div>
<p>and then write any DB-accessing code to be polymorphic over the surrounding context, as long as there’s a way to access a database connection:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">selectFrom ::</span> (<span class="dt">HasConnection</span> m, <span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">Table</span> a <span class="ot">-&gt;</span> m [a]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>selectFrom table <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  conn <span class="ot">&lt;-</span> getConnection</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  runBeamSqlite conn <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    rows <span class="ot">&lt;-</span> runSelectReturningList (select <span class="op">...</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>getUserById </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">HasConnection</span> m, <span class="dt">MonadIO</span> m) </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> <span class="dt">User</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>getUserById <span class="fu">id</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  users <span class="ot">&lt;-</span> selectFrom userTable </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> find ((<span class="fu">id</span> <span class="op">==</span>) <span class="op">.</span> userId) users</span></code></pre></div>
<p>To run your app, you could then wrap up any required context into a product type and thread that data along implicitly using a <code class="inline-type">ReaderT</code> effect:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- class MonadReader r m | m -&gt; r where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   asks :: (r -&gt; a) -&gt; m a</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   ask :: m r</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   ask = asks id</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- newtype ReaderT r m a = ReaderT {runReaderT :: r -&gt; m a}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- instance Applicative m =&gt; MonadReader r (ReaderT r m) where </span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">--   asks f = ReaderT (pure . f)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AppCtx</span> <span class="ot">=</span> <span class="dt">AppCtx</span> </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> _dbConn ::</span> <span class="dt">SomeConnection</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _numThreads ::</span> <span class="dt">Int</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _apiToken ::</span> <span class="dt">Text</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadReader</span> <span class="dt">AppCtx</span> m <span class="ot">=&gt;</span> <span class="dt">HasConnection</span> m <span class="kw">where</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  getConnection <span class="ot">=</span> asks _dbConn</span></code></pre></div>
<p>And let’s assume that there are some other ops in the meantime that can fail, so we want some way of exiting early. Cue <code class="inline-type">ExceptT</code> and <code class="inline-type">MonadError</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- class MonadError err m where </span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   throwError :: forall a. e -&gt; m a</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   catchError :: m a -&gt; (e -&gt; m a) -&gt; m a </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- newtype ExceptT e m a = ExceptT {runExceptT :: m (Either e a)}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>server </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">HasConnection</span> m, <span class="dt">MonadIO</span> m, <span class="dt">MonadError</span> <span class="dt">String</span> m)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> m ()</span></code></pre></div>
<p>Monad transformers are meant to stack, so after creating your app context:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">connectDB ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">SomeConnection</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mkAppCtx ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">AppCtx</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>mkAppCtx tok <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  eitherConn <span class="ot">&lt;-</span> connectDB <span class="st">&quot;Data Source=:memory:&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  forM eitherConn \conn <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    threads <span class="ot">&lt;-</span> getNumCapabilities</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="op">$</span> <span class="dt">AppCtx</span> conn threads tok</span></code></pre></div>
<p>It’s a simple matter of instantiating the exact order of effects you want, then tearing those pieces down until you reach IO:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ignoring other details because I'm lazy</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runApp ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>runApp <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> ctx <span class="ot">&lt;-</span> mkAppCtx <span class="st">&quot;some token&quot;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- at this point, server is inferred to have the type</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ExceptT String (ReaderT AppCtx IO) ()</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  serverRes <span class="ot">&lt;-</span> runExceptT <span class="op">$</span> runReaderT server ctx</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">either</span> <span class="fu">putStrLn</span> <span class="fu">pure</span> serverRes </span></code></pre></div>
<p>You could also flip this stack around since <code>mkAppCtx</code> returns an <code class="inline-mod">IO (Either ..)</code> value:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runApp' ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> ())</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>runApp' <span class="ot">=</span> runExceptT <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  ctx <span class="ot">&lt;-</span> <span class="dt">ExceptT</span> <span class="op">$</span> mkAppCtx <span class="st">&quot;some token&quot;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- server :: ReaderT AppCtx (ExceptT String IO) ()</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  runReaderT server ctx</span></code></pre></div>
<p>Semantically and representationally, <code>server</code> in both cases is the same, even though their (wrapped) types differ.</p>
<p>Expanding <code>server</code> from both examples:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">server1 ::</span> <span class="dt">ExceptT</span> <span class="dt">String</span> (<span class="dt">ReaderT</span> <span class="dt">AppCtx</span> <span class="dt">IO</span>) ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a> <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="dt">AppCtx</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> ()) </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a> <span class="ot">=</span> <span class="dt">AppCtx</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> ())</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="ot">server2 ::</span> <span class="dt">ReaderT</span> <span class="dt">AppCtx</span> (<span class="dt">ExceptT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a> <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="dt">AppCtx</span> (<span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> ()))</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a> <span class="ot">=</span> (<span class="dt">AppCtx</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> ()))</span></code></pre></div>
<p>The problem is that not every permutation of a series of monad transformers is equivalent. Let’s say you had some stateful effect that could throw an error, like running a block cipher, parsing, etc:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- newtype StateT s m a </span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  = StateT {runStateT :: s -&gt; m (a, s)}</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- evalStateT :: StateT s m a -&gt; m a</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- execStateT :: StateT s m a -&gt; m s</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- class MonadState s m where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">--   get :: m s</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">--   put :: s -&gt; m ()</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">--   modify :: (s -&gt; s) -&gt; m ()</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">SomeState</span> <span class="ot">=</span> <span class="dt">SomeState</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="kw">newtype</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="ot">someStateOp ::</span> (<span class="dt">MonadState</span> <span class="dt">SomeState</span> m, <span class="dt">MonadIO</span> m, <span class="dt">MonadError</span> <span class="dt">String</span> m) <span class="ot">=&gt;</span> m ()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>someStateOp <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeState</span> cur <span class="ot">&lt;-</span> get</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  when (cur <span class="op">==</span> <span class="dv">69</span>) <span class="op">$</span> throwError <span class="st">&quot;not cool&quot;</span> </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">print</span> cur</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  put (<span class="dt">SomeState</span> <span class="op">$</span> cur <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>We could run this in two ways: layer the <code class="inline-type">ExceptT</code> on top of the <code class="inline-type">StateT</code>, or the other way around.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">res1 ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> ((), <span class="dt">SomeState</span>))</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>res1 <span class="ot">=</span> runExceptT (runStateT someStateOp (<span class="dt">SomeState</span> <span class="dv">0</span>))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">res2 ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> (), <span class="dt">SomeState</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>res2 <span class="ot">=</span> runStateT (runExceptT someStateOp) (<span class="dt">SomeState</span> <span class="dv">0</span>)</span></code></pre></div>
<p>What the hell?? Flipping the order of the two effects results in two different types, and differing semantics altogether. If <code class="inline-type">StateT</code> is on the outside, we run the risk of losing our state entirely if an error is thrown.</p>
<p>Expanded:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stateOp1 ::</span> <span class="dt">StateT</span> <span class="dt">SomeState</span> (<span class="dt">ExceptT</span> <span class="dt">String</span> <span class="dt">IO</span>) ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">SomeState</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">String</span> <span class="dt">IO</span> ((), <span class="dt">SomeState</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">SomeState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> ((), <span class="dt">SomeState</span>)) </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">stateOp2 ::</span> <span class="dt">ExceptT</span> <span class="dt">String</span> (<span class="dt">StateT</span> <span class="dt">SomeState</span> <span class="dt">IO</span>) ()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">SomeState</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> ())</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">SomeState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> (), <span class="dt">SomeState</span>)</span></code></pre></div>
<p>There’s also the issue of extensibility - <code>mtl</code>-style transformer stacks are implemented using a type class for each effect (<code class="inline-type">MonadState</code>, <code class="inline-type">MonadError</code>, <code class="inline-type">MonadCont</code>, etc.). Monad transformers are parameterized by the ability to <code>lift</code> an operation from a lower monad into a higher one, and polymorphism is obtained by creating instances for each transformer, for each effect. If you have a <code class="inline-type">StateT s</code> wrapper somewhere in your stack, then the stack implements <code class="inline-type">MonadState s</code> at that level. A <code class="inline-type">ReaderT env</code> on top of that <code class="inline-type">StateT</code> would provide <code class="inline-type">MonadReader env</code>, as well as <code class="inline-type">MonadState s</code> through an instance on <code class="inline-type">ReaderT env</code>. Here’s an example:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- class MonadTrans (t :: (Type -&gt; Type) -&gt; Type -&gt; Type) where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   lift :: m a -&gt; t m a</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">IdT</span> m a <span class="ot">=</span> <span class="dt">IdT</span> {<span class="ot">getIdT ::</span> m a} </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadTrans</span> <span class="dt">IdT</span> <span class="kw">where</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  lift <span class="ot">=</span> <span class="dt">IdT</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="dt">IdT</span> m) <span class="kw">where</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  get <span class="ot">=</span> lift get</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  put <span class="ot">=</span> lift <span class="op">.</span> put</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadError</span> e m <span class="ot">=&gt;</span> <span class="dt">MonadError</span> e (<span class="dt">IdT</span> m) <span class="kw">where</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  throwError <span class="ot">=</span> lift <span class="op">.</span> throwError</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  catchError (<span class="dt">IdT</span> act) k <span class="ot">=</span> lift <span class="op">$</span> catchError act (getIdT <span class="op">.</span> k)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- and so on</span></span></code></pre></div>
<p>It’s pretty easy to see that this is a ton of boilerplate, and introducing a new effect means writing another row of (pretty trivial) instances. Work on the order of <code>n^2</code> is pretty bad. This is worse when you add <code class="inline-type">MonadIO</code> into the mix, requiring another set of identical <code>liftIO = lift . liftIO</code> instance bodies.</p>
<hr>
<h2>
introducing extensible effects, operationally
</h2>
<p>So what exactly is an “effect”? It doesn’t really make sense for a purely functional language to modify the surrounding world, destructively update global variables, etc.</p>
<p>I like to think of effects more as passing around/manipulating contexts - in the monad transformer approach, every “layer” of your stack carries some semantic information:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- here's an environment you can use for your monadic computation</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ReaderT'</span> r m a <span class="ot">=</span> <span class="dt">ReaderT'</span> (r <span class="ot">-&gt;</span> m a)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- here's a state, gimme back a value and a new state</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">StateT'</span> s m a <span class="ot">=</span> <span class="dt">StateT'</span> (s <span class="ot">-&gt;</span> m (a, s))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- your computation might fail with an error `e`</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ExceptT'</span> e m a <span class="ot">=</span> <span class="dt">ExceptT'</span> (m (<span class="dt">Either</span> e a))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- give me something to do with an `a` and I'll do that with an `a`</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ContT'</span> r m a <span class="ot">=</span> <span class="dt">ContT'</span> ((a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- give me ANYTHING you wanna do with an `a`, I promise I have one</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- good luck trying to callCC though :^)</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">CodensityT'</span> m a <span class="ot">=</span> <span class="dt">CodensityT'</span> (<span class="kw">forall</span> r<span class="op">.</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r)</span></code></pre></div>
<p>and the <em>composition</em> of those layers creates a stack of contexts that interact generically:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readerExcState ::</span> </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ReaderT'</span> <span class="dt">String</span> </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">ExceptT'</span> <span class="dt">String</span> </span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">StateT'</span> <span class="dt">Int</span> <span class="dt">Identity</span>)) </span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  ()</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>readerExcState <span class="ot">=</span> </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ReaderT'</span> \env <span class="ot">-&gt;</span> </span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">ExceptT'</span> <span class="op">$</span> </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">StateT'</span> \st <span class="ot">-&gt;</span> <span class="dt">Identity</span> </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>          (<span class="dt">Left</span> (<span class="st">&quot;thanks for the string: &quot;</span> <span class="op">&lt;&gt;</span> env), st <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- these definitions are isomorphic</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="ot">flattenedReadExcSt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Either</span> <span class="dt">String</span> (), <span class="dt">Int</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>flattenedReadExcSt <span class="ot">=</span> coerce readerExcState</span></code></pre></div>
<p>The idea behind extensible effects is a sort of inversion of control - while monad transformers capture this idea of “here’s a context, and a set of operations you can do on that context”, effects libraries expand that to “here’s a set of operations I want to do, figure out a context for that and how to achieve them”. We can achieve a first iteration using an <a href="https://themonadreader.files.wordpress.com/2010/01/issue15.pdf#page=37&amp;zoom=auto,-13,725">Operational</a> monad, transforming things into a more inspectable form.</p>
<p>Let’s say you wanted to encode a stateful operation. Instead of using a black-box function from a state <code>s</code> to a result and new state <code>(a, s)</code>, you can distill your intention down to two commands:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StateCmd</span> s a <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">StateCmd</span> s s</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Put</span><span class="ot"> ::</span> s <span class="ot">-&gt;</span> <span class="dt">StateCmd</span> s ()</span></code></pre></div>
<p>and decompose the idea of monad into its operations:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Prog</span> cmd a <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd a</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bind</span><span class="ot"> ::</span> <span class="dt">Prog</span> cmd a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd b) <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd b</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Command</span><span class="ot"> ::</span> cmd a <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd a</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Prog</span> cmd) <span class="kw">where</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- every Monad is a Functor because</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- fmap f ma = ma &gt;&gt;= (pure . f)</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f prog <span class="ot">=</span> <span class="dt">Bind</span> prog (<span class="dt">Pure</span> <span class="op">.</span> f)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Prog</span> cmd) <span class="kw">where</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd a</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Pure</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&lt;*&gt;) ::</span> <span class="dt">Prog</span> cmd (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd a <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd b</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- literally the definition of `ap`</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>  progab <span class="op">&lt;*&gt;</span> proga <span class="ot">=</span> <span class="dt">Bind</span> progab </span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    \ab <span class="ot">-&gt;</span> <span class="dt">Bind</span> proga </span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>      \a <span class="ot">-&gt;</span> <span class="dt">Pure</span> (ab a)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Prog</span> cmd) <span class="kw">where</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">Prog</span> cmd a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd b) <span class="ot">-&gt;</span> <span class="dt">Prog</span> cmd b</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&gt;&gt;=</span>) <span class="ot">=</span> <span class="dt">Bind</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- a monolithic function that you can't introspect</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="ot">stateFunc ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>stateFunc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>  curState <span class="ot">&lt;-</span> get</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>  put <span class="op">$</span> <span class="kw">if</span> <span class="fu">even</span> curState <span class="kw">then</span> curState <span class="ot">`div`</span> <span class="dv">2</span> <span class="kw">else</span> curState <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (curState <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- an AST</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a><span class="ot">stateProg ::</span> <span class="dt">Prog</span> (<span class="dt">StateCmd</span> <span class="dt">Int</span>) <span class="dt">Int</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>stateProg <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>  curState <span class="ot">&lt;-</span> <span class="dt">Command</span> <span class="dt">Get</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Command</span> <span class="op">$</span> <span class="dt">Put</span> (<span class="kw">if</span> <span class="fu">even</span> curState <span class="kw">then</span> curState <span class="ot">`div`</span> <span class="dv">2</span> <span class="kw">else</span> curState <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pure</span> (curState <span class="op">*</span> <span class="dv">3</span>)</span></code></pre></div>
<p>With your defunctionalized monad, you’re now free to interpret that AST into whatever monad you wanted. If you want to emulate the regular <code class="inline-type">State</code> monad, you could just pass around a state manually:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interpretState ::</span> <span class="dt">Prog</span> (<span class="dt">StateCmd</span> s) a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s) </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>interpretState (<span class="dt">Pure</span> a) s <span class="ot">=</span> (a, s)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>interpretState (<span class="dt">Bind</span> prog next) s <span class="ot">=</span> </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (a, s') <span class="ot">=</span> interpretState prog s</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>      nextProg <span class="ot">=</span> next a</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> interpretState nextProg s'</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- the GADT definitions give us witnesses for the type of `a`</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>interpretState (<span class="dt">Command</span> <span class="dt">Get</span>) s <span class="ot">=</span> (s, s)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>interpretState (<span class="dt">Command</span> (<span class="dt">Put</span> newState)) _ <span class="ot">=</span> ((), newState)</span></code></pre></div>
<p>Or you could interpret it using a mutable reference in the <code class="inline-type">ST</code> monad, which can be much <a href="https://www.reddit.com/r/haskell/comments/1rcc8t/performance_of_the_st_monad_over_the_state_monad/">faster due to lower GC pressure</a>. On a side note, there’s a strong similarity here to a simple <code class="inline-type">ReaderT (STRef st s) (ST st) a</code>. Instead of threading immutable values, we use an immutable reference to one mutable variable:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interpretST ::</span> <span class="kw">forall</span> a s<span class="op">.</span> <span class="dt">Prog</span> (<span class="dt">StateCmd</span> s) a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>interpretST prog initial <span class="ot">=</span> runST foldProg <span class="kw">where</span> </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- we need explicit type signatures because of runST's Rank 2 type</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldProg ::</span> <span class="kw">forall</span> st<span class="op">.</span> <span class="dt">ST</span> st (a, s)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  foldProg <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    stateRef <span class="ot">&lt;-</span> newSTRef initial</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span><span class="ot"> loop ::</span> <span class="dt">Prog</span> (<span class="dt">StateCmd</span> s) b <span class="ot">-&gt;</span> <span class="dt">ST</span> st b</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        loop <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Pure</span> a <span class="ot">-&gt;</span> <span class="fu">pure</span> a</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Bind</span> cur next <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>            output <span class="ot">&lt;-</span> loop cur</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>            loop (next output)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Command</span> <span class="dt">Get</span> <span class="ot">-&gt;</span> readSTRef stateRef</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Command</span> (<span class="dt">Put</span> new) <span class="ot">-&gt;</span> writeSTRef stateRef new</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    res <span class="ot">&lt;-</span> loop prog</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    finalState <span class="ot">&lt;-</span> readSTRef stateRef</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> (res, finalState)</span></code></pre></div>
<p>This approach works just fine, but if we want to compete with monad transformers, we need a way to express <em>multiple</em> effects.</p>
<hr>
<h3>
decomposing more than a single type
</h3>
<p>There’s been a ton of research/functional pearls published on the use of a combination of type-indexed functors and free monads to write expressive code with minimal boilerplate. My first intro to the topic was <a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf">Data types a la carte</a> by Wouter Sweirstra - he explores the use of fixed-points over functors along with typed unions to create syntax trees that can be interpreted generically, introspected, and open for extension as needed.</p>
<p>The gist of the paper is that you can define a simple coproduct (aka a disjoint union) of two functors:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- compare with Either (f a) (g a)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- the inhabitants of (f :+: g) a = count(f a) + count(g a)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> (f <span class="op">:+:</span> g) a <span class="ot">=</span> <span class="dt">InL</span> (f a) <span class="op">|</span> <span class="dt">InR</span> (g a) <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">7</span> <span class="op">:+:</span></span></code></pre></div>
<p>Along with a fixed point over functors:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- try expressing this in Rust if you hate your computer</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f)) </span></code></pre></div>
<p>to create what’s essentially a list of nested contexts. This list can be folded into a summary value using an <a href="https://www.schoolofhaskell.com/user/bartosz/understanding-algebras">F-algebra</a>, much in the same way as regular lists:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldExpr ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>foldExpr fold (<span class="dt">Fix</span> f) <span class="ot">=</span> fold (foldExpr fold <span class="op">&lt;$&gt;</span> f)</span></code></pre></div>
<p>Here’s some <a href="https://bartoszmilewski.com/2020/04/09/initial-algebra-as-directed-colimit/">further</a> <a href="https://bartoszmilewski.com/2017/02/28/f-algebras/">reading</a> from epic-polish-category-theory-man if you’re interested.</p>
<p>Now I bet you’re thinking, “how does this even terminate???”, and you’re right if <code>f</code> is instantiated to some functor like <code class="inline-type">Identity</code>. The trick is to use functors with a phantom type as your base case (forming the leaves of the expression):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Val</span> a <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span> </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Num</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock <span class="dt">Functor</span></span></code></pre></div>
<p>And the nodes:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Add</span> a <span class="ot">=</span> <span class="dt">Add</span> a a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>Now the coproduct of these two types is:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ValOrAdd</span> <span class="ot">=</span> (<span class="dt">Val</span> <span class="op">:+:</span> <span class="dt">Add</span>)</span></code></pre></div>
<p>This type is isomorphic to what we’d usually reach for in these situations, a simple unified sum type:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AST</span> <span class="ot">=</span> <span class="dt">ASTVal</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">ASTAdd</span> <span class="dt">AST</span> <span class="dt">AST</span></span></code></pre></div>
<p>Notice that we’re basically just defining extensible, open sum types instead of putting everything in one place.</p>
<p>If we want to add another operation, we can burrito up another layer inductively since <code>(:+:)</code> is itself a functor:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mul</span> a <span class="ot">=</span> <span class="dt">Mul</span> a a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ValOrAddOrMul</span> <span class="ot">=</span> (<span class="dt">Val</span> <span class="op">:+:</span> <span class="dt">Add</span> <span class="op">:+:</span> <span class="dt">Mul</span>)</span></code></pre></div>
<p>Similar to our monad transformer stacks, the order of our effects is just the order of our coproduct. The difference is that we’ve centralized things to revolve around compositions of <code>:+:</code>, instead of treating each node as a distinct type with its own effect AND implementation.</p>
<p>For clarity, we know that given a coproduct <code>f :+: g</code>, we can always inject an <code>f</code> into that coproduct, but can’t always get an <code>f</code> back out.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> sub, <span class="dt">Functor</span> sup) <span class="ot">=&gt;</span> sub <span class="op">:&lt;:</span> sup <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- inject</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  inj ::</span> sub a <span class="ot">-&gt;</span> sup a</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- project</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  prj ::</span> sup a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (sub a)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- compare with `lift` from `MonadTrans`</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> f <span class="op">:&lt;:</span> (f <span class="op">:+:</span> g) <span class="kw">where</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>  inj <span class="ot">=</span> <span class="dt">InL</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>  prj (<span class="dt">InL</span> fa) <span class="ot">=</span> <span class="dt">Just</span> fa</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>  prj (<span class="dt">InR</span> ga) <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>We can inject a functor into an imaginary coproduct containing only itself, and always get it back out:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- reflexivity</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> f <span class="op">:&lt;:</span> f <span class="kw">where</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  inj <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  prj <span class="ot">=</span> <span class="dt">Just</span></span></code></pre></div>
<p>And define these injections on arbitrarily nested coproducts, given that the functor we want to inject exists somewhere:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- induction on a list of functors: `f` isn't at the front, but exists in the rest of the list</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# OVERLAPPABLE #-}</span> </span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">Functor</span> f</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Functor</span> <span class="fu">head</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Functor</span> <span class="fu">tail</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  , f <span class="op">:&lt;:</span> <span class="fu">tail</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span> f <span class="op">:&lt;:</span> (<span class="fu">head</span> <span class="op">:+:</span> <span class="fu">tail</span>) <span class="kw">where</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- compare with `lift . lift`</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  inj <span class="ot">=</span> <span class="dt">InR</span> <span class="op">.</span> inj</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>  prj (<span class="dt">InL</span> _ ) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>  prj (<span class="dt">InR</span> ta) <span class="ot">=</span> prj ta</span></code></pre></div>
<p>Within a chain <code>f :+: g :+: h :+: ...</code>, there’s only ever a single value. We’re defining the equivalent of <code>union</code>s in other languages, but with some more structure.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- called `inject` in the original paper</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ot">liftFix ::</span> (g <span class="op">:&lt;:</span> f) <span class="ot">=&gt;</span> g (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>liftFix <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">.</span> inj</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Val (Fix f) is our base case, since it's a phantom type</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="ot">val ::</span> <span class="dt">Val</span> <span class="op">:&lt;:</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>val <span class="ot">=</span> liftFix <span class="op">.</span> <span class="dt">Val</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- a binary AST node</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Add</span> <span class="op">:&lt;:</span> f <span class="ot">=&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>add l r <span class="ot">=</span> liftFix (<span class="dt">Add</span> l r)</span></code></pre></div>
<p>Now, we can use type classes to implement our effects in a manner that only requires <code>n</code> instances. That’s a whole order of magnitude less, wew:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Eval</span> f <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  evalAlg ::</span> f <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Val</span> <span class="kw">where</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  evalAlg (<span class="dt">Val</span> n) <span class="ot">=</span> n</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Add</span> <span class="kw">where</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  evalAlg (<span class="dt">Add</span> l r) <span class="ot">=</span> l <span class="op">+</span> r</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Eval</span> f, <span class="dt">Eval</span> g) <span class="ot">=&gt;</span> <span class="dt">Eval</span> (f <span class="op">:+:</span> g) <span class="kw">where</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  evalAlg (<span class="dt">InL</span> f) <span class="ot">=</span> evalAlg f </span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  evalAlg (<span class="dt">InR</span> g) <span class="ot">=</span> evalAlg g</span></code></pre></div>
<p>And now, to fold any arbitrary arithmetic tree:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalFix ::</span> <span class="dt">Eval</span> f <span class="ot">=&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>evalFix <span class="ot">=</span> foldExpr evalAlg</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">ten ::</span> <span class="dt">Fix</span> (<span class="dt">Add</span> <span class="op">:+:</span> <span class="dt">Val</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>ten <span class="ot">=</span> val <span class="dv">1</span> <span class="ot">`add`</span> val <span class="dv">2</span> <span class="ot">`add`</span> val <span class="dv">3</span> <span class="ot">`add`</span> val <span class="dv">4</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; evalFix ten</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- 10</span></span></code></pre></div>
<p>Yes, this is just <a href="http://www.cs.nott.ac.uk/~pszgmh/exceptions.pdf">Hutton’s Razor</a> with extra steps. A lot of extra steps. But consider a more complicated case where we had more constructors to deal with, and more operations. Adding another constructor would affect every single pattern match site in your code, and lead to a refactoring annoyance, if not a nightmare for larger projects.</p>
<p>In contrast, let’s implement multiplication now:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Mul</span> <span class="kw">where</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  evalAlg (<span class="dt">Mul</span> l r) <span class="ot">=</span> l <span class="op">*</span> r</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">mul ::</span> <span class="dt">Mul</span> <span class="op">:&lt;:</span> f <span class="ot">=&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>mul l r <span class="ot">=</span> liftFix (<span class="dt">Mul</span> l r)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="ot">nice ::</span> <span class="dt">Fix</span> (<span class="dt">Mul</span> <span class="op">:+:</span> <span class="dt">Add</span> <span class="op">:+:</span> <span class="dt">Val</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>nice <span class="ot">=</span> (val <span class="dv">24</span> <span class="ot">`add`</span> val <span class="dv">18</span>) <span class="ot">`mul`</span> (val <span class="dv">5</span> <span class="ot">`add`</span> val <span class="dv">1</span> <span class="ot">`add`</span> val <span class="dv">4</span>)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; evalFix nice</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- 420</span></span></code></pre></div>
<p>Any point in your codebase that uses only <code class="inline-type">Add</code> or <code class="inline-type">Val</code> will be untouched, and you’re free to keep hacking away knowing that you haven’t left any unhandled cases in your wake.</p>
<hr>
<h2>
something something free lunch
</h2>
<p>Now that we’ve written the basis for an extensible, low-boilerplate effects system, it’s time to scrap everything and do something cooler.</p>
<p>You might have noticed that <code class="inline-type">Fix</code> is just one half of another type that’s gotten a lot of attention lately, the <code class="inline-type">Free</code> monad:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> f a</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Pure</span> a</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>which you can think of as <code class="inline-type">Fix f</code> plus a terminating value, solving the problem of types like <code class="inline-type">Fix Identity</code> being truly infinite.</p>
<p>I won’t go too deeply into free monads since there are <a href="https://www.tweag.io/blog/2018-02-05-free-monads/">plenty</a> of <a href="https://iohk.io/en/blog/posts/2018/08/07/from-free-algebras-to-free-monads/">resources</a> <a href="http://comonad.com/reader/2008/monads-for-free/">already</a> on the topic. The gist of it is that the name <code class="inline-type">Free</code> is pretty literal; you get a <code class="inline-type">Monad</code> for free from any <code class="inline-type">Functor</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Pure</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pure</span> a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f a</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Free</span> fa <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Free</span> ((<span class="op">&gt;&gt;=</span> f) <span class="op">&lt;$&gt;</span> fa)</span></code></pre></div>
<p>This is the traditional representation, and some of its flaws are pretty apparent from the implementation: left-associative <code class="inline-op">(&gt;&gt;=)</code>’s require you to traverse down the entire stack, pissing off both the garbage collector and your QA team. It’s akin to treating our lists like Python’s “lists”:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>goodListIdentity,<span class="ot"> badListIdentity ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- O(n)</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>goodListIdentity <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">:</span>) []</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- O(n^2)</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>badListIdentity  <span class="ot">=</span> <span class="fu">foldl</span> (\a x <span class="ot">-&gt;</span> a <span class="op">&lt;&gt;</span> [x]) []</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- foldl' won't save you</span></span></code></pre></div>
<p>You can use a combination of F-algebras and the <code class="inline-type">Yoneda</code> lemma to encode a free monad much more cheaply from the bottom-up, given that function composition is cheap as heck (credits to <a href="http://comonad.com/reader/2011/free-monads-for-less-2/">Edward Kmett’s blog</a>):</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- the spookiest isomorphism in category theory</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- basically a suspended fmap, allowing for traversals through `f` to be delayed until you need them</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Yoneda</span> f a <span class="ot">=</span> <span class="dt">Yoneda</span> {<span class="ot">runYoneda ::</span> <span class="kw">forall</span> b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b}</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="ot">toYoneda ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Yoneda</span> f a</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>toYoneda fa <span class="ot">=</span> <span class="dt">Yoneda</span> (<span class="ot">`fmap`</span> fa)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="ot">fromYoneda ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Yoneda</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>fromYoneda yon <span class="ot">=</span> runYoneda yon <span class="fu">id</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- not a Functor, try it for yourself</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">FAlg</span> f r <span class="ot">=</span> <span class="dt">FAlg</span> {<span class="ot">runFAlg ::</span> (f r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r}</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Free'</span> f a <span class="ot">=</span> <span class="dt">Free'</span> (<span class="dt">Yoneda</span> (<span class="dt">FAlg</span> f) a)</span></code></pre></div>
<p>but triply nested newtypes are annoying, so let’s expand things into our final representation:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Free</span> f a <span class="ot">=</span> <span class="dt">Free</span> </span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> runFree ::</span> <span class="kw">forall</span> r<span class="op">.</span> </span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    (a <span class="ot">-&gt;</span> r) <span class="co">-- extract a pure value</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (f r <span class="ot">-&gt;</span> r) <span class="co">-- fold f using an F-algebra</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> r</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Free</span> \k _ <span class="ot">-&gt;</span> k x</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&lt;*&gt;) ::</span> <span class="kw">forall</span> a b<span class="op">.</span> <span class="dt">Free</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f b</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Free</span> f b) <span class="ot">-&gt;</span> <span class="dt">Free</span> f b</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>  fa <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Free</span> </span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    \(<span class="ot">br ::</span> b <span class="ot">-&gt;</span> <span class="fu">any</span>) </span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>     (<span class="ot">frr ::</span> f <span class="fu">any</span> <span class="ot">-&gt;</span> <span class="fu">any</span>) <span class="ot">-&gt;</span> </span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>       runFree fa </span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>        (\a <span class="ot">-&gt;</span> runFree (f a) br frr) </span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>        frr</span></code></pre></div>
<p>By ‘flipping’ our representation around into one that threads around continuations, we end up with pretty heavy asymptotic improvements over the naive form. The F-algebra ((<code>f r -&gt; r</code>), previously the <code class="inline-type">FAlg f r</code> component) is unused in these instances, but it’s going to form the basis for how we’ll end up interpreting effects later on.</p>
<p>Now that we have a better way of constructing syntax trees, let’s look at our previous encoding of type-level unions. Why not improve our ergonomics a bit?</p>
<p>Side note, this document is a Literate Haskell file and I’ve had to enable like 2000000 extensions by this point. Kindly turn on <code class="inline-type">GADTs</code>, <code class="inline-type">PolyKinds</code>, <code class="inline-type">DataKinds</code>, and <code class="inline-type">KindSignatures</code> if you’re following along.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- does every type in the list satisfy the constraint?</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ForAll</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">ForAll</span> cs items <span class="kw">where</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ForAll</span> _ '[] <span class="ot">=</span> () <span class="co">-- empty constraint</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ForAll</span> cs (item '<span class="op">:</span> items) <span class="ot">=</span> (cs item, <span class="dt">ForAll</span> cs items) </span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- a list of functors and a single inhabitant</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Union</span> (<span class="ot">fs ::</span> [<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>]) a <span class="kw">where</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- end of the list</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Here</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Union</span> '[f] a</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- either f a, or a union of the list's tail</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">There</span><span class="ot"> ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (f <span class="op">:+:</span> <span class="dt">Union</span> fs) a <span class="ot">-&gt;</span> <span class="dt">Union</span> (f '<span class="op">:</span> fs) a</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Functor</span> <span class="ot">`ForAll`</span> fs <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Union</span> fs)</span></code></pre></div>
<p>Previously, our instances for finding a subtype <code>f</code> within a coproduct <code>f :+: g</code> assumed that the coproduct was built right-associatively, that is, <code>f :+: g :+: h</code> implies <code>f :+: (g :+: h)</code>. Encoding things with a GADT has two advantages: this structure is enforced, and it’s easier to type <code>[Maybe, Either Char, IO, ...]</code> than <code>(Maybe :+: Either Char :+: IO :+: ...)</code>.</p>
<p>Let’s define another class for finding <code class="inline-type">Union</code> membership too, although we could reuse <code>(:&lt;:)</code> for this:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> f , <span class="dt">Functor</span> <span class="ot">`ForAll`</span> fs) <span class="ot">=&gt;</span> <span class="dt">Member</span> (<span class="ot">f ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) (<span class="ot">fs ::</span> [<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>]) <span class="kw">where</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  inject ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Union</span> fs a </span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  project ::</span> <span class="dt">Union</span> fs a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (f a)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Functor</span> <span class="ot">`ForAll`</span> (f '<span class="op">:</span> fs)) <span class="ot">=&gt;</span> <span class="dt">Member</span> f (f '<span class="op">:</span> fs) <span class="kw">where</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  inject <span class="ot">=</span> <span class="dt">There</span> <span class="op">.</span> <span class="dt">InL</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- f occurs at the end</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  project (<span class="dt">Here</span> fa) <span class="ot">=</span> <span class="dt">Just</span> fa</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- f occurs at the front, and is inhabited</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  project (<span class="dt">There</span> (<span class="dt">InL</span> fa)) <span class="ot">=</span> <span class="dt">Just</span> fa</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>  project _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# OVERLAPPABLE #-}</span> (<span class="dt">Functor</span> g, <span class="dt">Member</span> f fs) <span class="ot">=&gt;</span> <span class="dt">Member</span> f (g '<span class="op">:</span> fs) <span class="kw">where</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>  inject <span class="ot">=</span> <span class="dt">There</span> <span class="op">.</span> <span class="dt">InR</span> <span class="op">.</span> inject</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>  project (<span class="dt">There</span> (<span class="dt">InR</span> fa)) <span class="ot">=</span> project fa</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>  project _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This is a ton of code at this point with no testing, so let’s prove that the implementation of <code class="inline-type">Union</code> is well-typed:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someUnion ::</span> <span class="dt">Union</span> [<span class="dt">Either</span> <span class="dt">String</span>, <span class="dt">Maybe</span>, <span class="dt">IO</span>, <span class="dt">Add</span>, <span class="dt">Mul</span>] <span class="dt">Int</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>someUnion <span class="ot">=</span> inject (<span class="dt">Just</span> <span class="dv">1</span>) </span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- There $ InR $ There $ InL (Just 1)</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="ot">someIO ::</span> <span class="dt">Maybe</span> (<span class="dt">IO</span> <span class="dt">Int</span>)</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>someIO <span class="ot">=</span> project someUnion</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just (Just 1)</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="ot">someMaybe ::</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>someMaybe <span class="ot">=</span> project someUnion</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- use another union as a witness to help type inference</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a><span class="ot">injectAs ::</span> <span class="dt">Member</span> f fs <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Union</span> fs b <span class="ot">-&gt;</span> <span class="dt">Union</span> fs a</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>injectAs fs _ <span class="ot">=</span> inject fs</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>injIO, injectEither </span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">Union</span> '[<span class="dt">Either</span> <span class="dt">String</span>, <span class="dt">Maybe</span>, <span class="dt">IO</span>, <span class="dt">Add</span>, <span class="dt">Mul</span>] <span class="dt">Int</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>injIO <span class="ot">=</span> injectAs (<span class="fu">read</span> <span class="op">&lt;$&gt;</span> <span class="fu">getLine</span>) someUnion</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>injectEither <span class="ot">=</span> injectAs notAnInt someUnion</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> notAnInt <span class="ot">=</span> <span class="dt">Left</span> <span class="op">@</span><span class="dt">String</span> <span class="st">&quot;lol u errored out&quot;</span></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- type error: No instance for Member (Either Text) '[]</span></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- someEitherText :: Maybe (Either Text Int)</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- someEitherText = project someUnion</span></span></code></pre></div>
<p>It might seem inefficient to have to traverse through the same list repeatedly, but we’re giving the compiler plenty of info on the exact path of each type within a <code class="inline-type">Union</code>, so we don’t need to worry too much.</p>
<p>Now it’s finally time to put it all together. First, let’s build some utils for our effects library:</p>
<p>We’re only ever going to use <code class="inline-type">Free</code> parameterized over some <code class="inline-type">Union</code> of functors, so let’s fix our core monad to that type:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> [<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>]) a <span class="ot">=</span> <span class="dt">Eff</span> </span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> runEff ::</span> <span class="kw">forall</span> r<span class="op">.</span> </span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    (a <span class="ot">-&gt;</span> r) </span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> (<span class="dt">Union</span> fs r <span class="ot">-&gt;</span> r) </span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> r</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>) via <span class="dt">Free</span> (<span class="dt">Union</span> fs)</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- god I love DerivingVia</span></span></code></pre></div>
<p>Now, we need ways to lift and unlift effects as needed:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- compare with `lift` from MonadTrans</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="ot">liftEff ::</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> f (<span class="ot">fs ::</span> [<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>]) a<span class="op">.</span> </span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Functor</span> f, <span class="dt">Member</span> f fs) </span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs a</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>liftEff fa <span class="ot">=</span> <span class="dt">Eff</span> </span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>  \(<span class="ot">ar ::</span> a <span class="ot">-&gt;</span> r) </span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>   (<span class="ot">frr ::</span> <span class="dt">Union</span> fs r <span class="ot">-&gt;</span> r) </span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> frr <span class="op">$</span> inject (ar <span class="op">&lt;$&gt;</span> fa)</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- we get this for freeeeeeeee</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Member</span> <span class="dt">IO</span> fs <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">Eff</span> fs) <span class="kw">where</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs a</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="ot">=</span> liftEff</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- given a natural transformation on a `Union`</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- (either adding or removing a functor),</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- lift into a new context</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a><span class="ot">hoist ::</span> (<span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Union</span> fs x <span class="ot">-&gt;</span> <span class="dt">Union</span> gs x) </span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs a </span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">Eff</span> gs a</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>hoist phi fr <span class="ot">=</span> <span class="dt">Eff</span> \kp kf <span class="ot">-&gt;</span> runEff fr kp (kf <span class="op">.</span> phi)</span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- Free monads correspond 1:1 to other monads given a natural transformation</span></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a><span class="ot">foldEff ::</span> <span class="dt">Monad</span> m </span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Union</span> fs x <span class="ot">-&gt;</span> m x) <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs a <span class="ot">-&gt;</span> m a</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>foldEff phi fr <span class="ot">=</span> runEff fr <span class="fu">pure</span> (join <span class="op">.</span> phi)</span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- peel off the top effect of an `Eff` stack by handling it in terms of other effects</span></span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- an `Eff` workflow works in terms of incrementally handling effects</span></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a>interpret </span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> f fs y<span class="op">.</span> (<span class="dt">Functor</span> <span class="ot">`ForAll`</span> (f '<span class="op">:</span> fs))</span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs x)</span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Eff</span> (f '<span class="op">:</span> fs) y </span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs y</span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a>interpret phi <span class="ot">=</span> foldEff \union <span class="ot">-&gt;</span> <span class="dt">Eff</span> \kp kf <span class="ot">-&gt;</span> </span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> exec fa <span class="ot">=</span> runEff (phi fa) kp kf</span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> <span class="kw">case</span> union <span class="kw">of</span></span>
<span id="cb44-39"><a href="#cb44-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Here</span> fa <span class="ot">-&gt;</span> exec fa</span>
<span id="cb44-40"><a href="#cb44-40" aria-hidden="true" tabindex="-1"></a>    <span class="dt">There</span> (<span class="dt">InL</span> fa) <span class="ot">-&gt;</span> exec fa</span>
<span id="cb44-41"><a href="#cb44-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">There</span> (<span class="dt">InR</span> other) <span class="ot">-&gt;</span> kf (kp <span class="op">&lt;$&gt;</span> other)</span>
<span id="cb44-42"><a href="#cb44-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-43"><a href="#cb44-43" aria-hidden="true" tabindex="-1"></a><span class="co">-- we can escape the Eff monad once all effects have been handled</span></span>
<span id="cb44-44"><a href="#cb44-44" aria-hidden="true" tabindex="-1"></a><span class="ot">runFinal ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Eff</span> '[m] a <span class="ot">-&gt;</span> m a</span>
<span id="cb44-45"><a href="#cb44-45" aria-hidden="true" tabindex="-1"></a>runFinal <span class="ot">=</span> foldEff \<span class="kw">case</span> </span>
<span id="cb44-46"><a href="#cb44-46" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Here</span> fx <span class="ot">-&gt;</span> fx</span>
<span id="cb44-47"><a href="#cb44-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- compiler can't infer that the list will never be non-empty</span></span>
<span id="cb44-48"><a href="#cb44-48" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Unreachable&quot;</span></span></code></pre></div>
<p>Congrats, now you have a fully-featured effects system in 200 lines of code. It’s <strong>finally</strong> time to try out some effects now, so we’ll use the classic <code class="inline-type">Teletype</code> example that everyone likes to reach for:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Teletype</span> a</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">PrintLn</span> <span class="dt">String</span> a</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">GetLine</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- the transformation from an Effect type to helper functions is mechanical </span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- and can be abstracted away with TemplateHaskell</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="ot">println ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> fs <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs ()</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>println s <span class="ot">=</span> liftEff (<span class="dt">PrintLn</span> s ())</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="ot">getLine_ ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> fs <span class="ot">=&gt;</span> <span class="dt">Eff</span> fs <span class="dt">String</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>getLine_ <span class="ot">=</span> liftEff (<span class="dt">GetLine</span> <span class="fu">id</span>)</span></code></pre></div>
<p>And some other effects for posterity, I guess:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FileSystem</span> a </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">ReadFile</span> <span class="dt">FilePath</span> (<span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">WriteFile</span> <span class="dt">FilePath</span> <span class="dt">String</span> a</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="ot">readFile_ ::</span> <span class="dt">Member</span> <span class="dt">FileSystem</span> fs <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>readFile_ path <span class="ot">=</span> liftEff (<span class="dt">ReadFile</span> path <span class="fu">id</span>)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a><span class="ot">writeFile_ ::</span> <span class="dt">Member</span> <span class="dt">FileSystem</span> fs <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs ()</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>writeFile_ path s <span class="ot">=</span> liftEff (<span class="dt">WriteFile</span> path s ())</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Error</span> e a <span class="ot">=</span> <span class="dt">Error</span> e <span class="kw">deriving</span> (<span class="dt">Functor</span>)</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="ot">throwErr ::</span> <span class="dt">Member</span> (<span class="dt">Error</span> e) fs <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">Eff</span> fs a</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>throwErr err <span class="ot">=</span> liftEff (<span class="dt">Error</span> err)</span></code></pre></div>
<p>And we’ll try seeing these effects in action now:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>interactiveCat </span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">Member</span> <span class="dt">FileSystem</span> fs, <span class="dt">Member</span> <span class="dt">Teletype</span> fs, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">String</span>) fs)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Eff</span> fs ()</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>interactiveCat <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  numFiles <span class="ot">&lt;-</span> readMaybe <span class="op">&lt;$&gt;</span> getLine_</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> numFiles <span class="kw">of</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> throwErr <span class="op">@</span><span class="dt">String</span> </span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Couldn't parse the number of files you want me to read!!&quot;</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> n <span class="ot">-&gt;</span> replicateM_ n <span class="kw">do</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>      path <span class="ot">&lt;-</span> getLine_</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>      mbFile <span class="ot">&lt;-</span> readFile_ path</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>      body <span class="ot">&lt;-</span> <span class="fu">maybe</span> (throwErr <span class="op">@</span><span class="dt">String</span> <span class="st">&quot;Couldn't locate file!!&quot;</span>) <span class="fu">pure</span> mbFile</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>      traverse_ println (<span class="fu">lines</span> body)</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a><span class="ot">ww ::</span> <span class="dt">IO</span> ()</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>ww <span class="ot">=</span> interactiveCat</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">&amp;</span> interpretFS</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">&amp;</span> interpret interpretTTY</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">&amp;</span> interpret interpretErr</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">&amp;</span> runFinal</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a><span class="ot">    interpretErr ::</span> <span class="dt">Error</span> <span class="dt">String</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> '[<span class="dt">IO</span>] a</span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    interpretErr <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a><span class="ot">    interpretFS ::</span> <span class="dt">Member</span> <span class="dt">IO</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">FileSystem</span> '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>    interpretFS <span class="ot">=</span> interpret \<span class="kw">case</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>      <span class="dt">ReadFile</span> path k <span class="ot">-&gt;</span> liftIO <span class="kw">do</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>        res <span class="ot">&lt;-</span> (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> path) <span class="ot">`catch`</span> \(<span class="ot">err ::</span> <span class="dt">IOException</span>) <span class="ot">-&gt;</span> </span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>          <span class="fu">print</span> err <span class="op">$&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> <span class="op">$</span> k res</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>      <span class="dt">WriteFile</span> path s k <span class="ot">-&gt;</span> </span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>        k <span class="op">&lt;$</span> liftIO (<span class="fu">writeFile</span> path s)</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- WriteFile path s k -&gt; do</span></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>    interpretTTY <span class="ot">=</span> liftIO <span class="op">.</span> \<span class="kw">case</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>      <span class="dt">PrintLn</span> line a <span class="ot">-&gt;</span> liftIO (<span class="fu">print</span> line) <span class="op">$&gt;</span> a</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>      <span class="dt">GetLine</span> k <span class="ot">-&gt;</span> k <span class="op">&lt;$&gt;</span> <span class="fu">getLine</span></span></code></pre></div>
<p>todo make interpret polymorphic so we can handle error effects properly talk about dependency injection/mocking</p>
    </section>
</article>

        </main>
          </div>
          <footer>
            <hr>
            <div id="footer-container">
              <div id="footer-text">
                <a style="color:yellow" href="../drafts.html">λ</a>2022 Norman Liu.  
                </span> 
              </div>
                <a href="mailto:norman@nliu.net" aria-label="Email address">
  <svg aria-hidden="true" pointer-events="none" focusable="false" data-prefix="fas" data-icon="envelope" class="svg-inline--fa fa-envelope fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </svg>
</a>
<a href="https://github.com/dreamsmasher" aria-label="GitHub profile">
  <svg aria-hidden="true" pointer-events="none" focusable="false" data-prefix="fab" data-icon="github-alt" class="svg-inline--fa fa-github-alt fa-w-15" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"></path>
  </svg>
</a>
<a href="https://linkedin.com/in/norman-wuwei-liu" aria-label="Linkedin profile">
  <svg aria-hidden="true" pointer-events="none" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path>
  </svg>
</a>
            </div>
          </footer>
    </body>
</html>
